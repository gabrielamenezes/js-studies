# Estudos Te√≥ricos - Javascript :books:
O objetivo desse reposit√≥rio √© organizar algumas teorias importantes do javascript, para melhorar a qualidade dos meus estudos e fixar melhor o conte√∫do. Fique a vontade para utilizar tamb√©m!

<em>Inspiration: [@isadorastan - estudos repository](https://github.com/isadorastan/estudos)</em>

## Sum√°rio
1. [Hoisting](#hoisting)
2. [Escopo](#escopo)
3. [Vari√°veis](#variaveis)
4. [Arrow Functions](#arrowfunc)

<h2 id="hoisting">Hoisting :fishing_pole_and_fish:</h2>

### O que √© o hoisting?
√â o conceito de que as declara√ß√µes de vari√°vel e fun√ß√£o s√£o colocadas na mem√≥ria durante a fase de compila√ß√£o, mas permanecem exatamente onde voc√™ as digitou. Isso, permite que voc√™ use uma fun√ß√£o ou vari√°vel antes mesmo de declar√°-la.

<em>fonte: [MDN Glossary - Hoisting](https://developer.mozilla.org/pt-BR/docs/Glossary/Hoisting)</em>

```js
    myName("Gabriela");
    function myName(name) {
        console.log("O meu nome √© " + name);
        // OUTPUT: O meu nome √© Gabriela
    }

```

A fun√ß√£o foi chamada antes mesmo de ser declarada, mas funciona.


O mesmo acontece para vari√°veis, mas nesse caso, o javascript eleva as declara√ß√µes, n√£o as inicializa√ß√µes.

```js

    console.log(num); // OUTPUT: undefined --> s√≥ foi declarada
    var num;
    num = 6;
    console.log(num) // OUTPUT: 6 -> agora inicializada

```

```js

    num = 6; // inicializa√ß√£o
    console.log(num); // OUTPUT: 6;
    var num; // declara√ß√£o


```

<h2 id="escopo">Escopo :mailbox:</h2>

### O que √© um escopo?
Escopo √© a acessibilidade de objetos, vari√°veis e fun√ß√µes em diferentes partes do c√≥digo.
Em outras palavras, o que determina quais s√£o os dados que podem ser acessados em uma determinada parte do c√≥digo √© o escopo.
Imagine que o escopo √© uma caixa e tudo que for criado nessa caixa pode ser acessado por qualquer objeto dentro da mesma. Um escopo √© criado sempre que definimos uma fun√ß√£o:

```js

    function hello(name) {
        // Isto aqui √© um escopo
    }

```


<em>fonte: https://imasters.com.br/desenvolvimento/escopos-em-javascript</em>

* Escopo Global
    * Uma vari√°vel global √© definida quando declaramos uma vari√°vel fora de qualquer fun√ß√£o, assim ela torna <strong>acess√≠vel a qualquer parte da nossa aplica√ß√£o ou site, podendo ser lida e alterada.</strong>
* Escopo Local
    * Uma vari√°vel se torna local quando ela √© declarada dentro de uma fun√ß√£o, de tal maneira a qual ela somente estar√° <strong> acess√≠vel dentro dessa fun√ß√£o.</strong>

    ```js

        function foo() {
            var name = 'Gabriela'
            let color = 'Blue'
            const age = 22
        }

        foo();

        //tentando acessar fora do escopo da fun√ß√£o
        console.log(name); // name is not defined
        console.log(color); // color is not defined
        console.log(age); // age is not defined

        //    Conclus√£o: name, color e age n√£o existem fora do escopo da fun√ß√£o foo. 
        //Isso significa, que podemos ter m√∫ltiplas fun√ß√µes com vari√°veis e constantes com o mesmo nome, mas que retornar√£o valores diferentes.

    ```



```js

    function color() {
        const color = 'pink'
        console.log(color) // pink
    }

    function color2() {
        const color = 'yellow'
        console.log(color) //yellow
    }

    color();
    color2();

```



* Escopo de Bloco
    * N√£o existia no JS escopo de bloco. Ou seja, for whiles e ifs n√£o tinham escopo pr√≥prio. Por√©m com o ECMAScript 6 foi poss√≠vel criar escopos de bloco usando as vari√°veis let e const, <strong>que s√£o acess√≠veis somente dentro do bloco.</strong>

    > Escopos criados por fun√ß√µes s√£o chamados de function scopes, enquanto escopos criados por estruturas de controle s√£o chamados de block scopes.

* Escopos Aninhados
    * Todo escopo √© fechado para acessos externos, de forma que escopos superiores n√£o conseguem acessar escopos internos, mas o contr√°rio √© permitido.

    ```js

    function foo() {
        function bar() {

        }
    }
    
    ```

    Quando criamos outra fun√ß√£o dentro da fun√ß√£o foo, estamos colocando outra caixa dentro do escopo da fun√ß√£o.

<h2 id="variaveis">Vari√°veis :package:</h2>

* var
    * √â i√ßada (veja em [Hoisting](#hoisting))
    * Tem escopo abrangente -> se for declarada dentro de um bloco -> vaza do escopo
    * Escopo global e fun√ß√£o -> n√£o tem escopo de bloco
    * Praticamente n√£o s√£o mais usadas em aplica√ß√µes devidos aos problemas de escopo -> <strong>substitu√≠das por let e const</strong>


```js
    if(true) {
        var global = 2; // vaza de dentro do bloco
    }

    function teste() {
        var global = 4;
        console.log(global); //4
    }

    console.log(global); //2 -> acessa a que vazou do if

```

* let e const
    * Tem escopo de bloco e de fun√ß√£o
    * Sofrem hoisting (s√£o elevadas) para o topo do bloco que foram definidas ‚Üí por√©m n√£o √© atribuido o valor de undefined como acontece com var ‚Üí continuam n√£o inicializadas e d√£o erro caso sejam chamadas antes de suas declara√ß√µes.
    * A grande diferen√ßa entre as duas √© que <strong>consts n√£o podem ser reatribu√≠das</strong> enquanto lets sim.

    ```js
        function name() {
	        console.log(name); // ‚ùå retorna erro porque ainda n√£o foi inicializada
	        let name = 'gabriela';
	        console.log(name); // üëçüèº gabriela
	        name = 'gabriela 2'; // üëçüèº pode ser reatru√≠da
        }

        const num = 6;
        num = 8; // ‚ùå N√£o pode ser reatribu√≠da porque √© const
    ```

<h2 id="arrowfunc">Arrow Functions :arrow_right:</h2>

### O que s√£o arrow functions?
Uma nova forma de escrita de uma fun√ß√£o, sempre √© uma fun√ß√£o an√¥nima

```js

const sum = (number1, number2) => {
    return number1 + number2;
}

console.log(sum(10,2)) // OUTPUT: 12

```

### Easter Eggs da Arrow Function
* retornando sem return
    * Se voc√™ usa uma arrow function sem as chaves, consegue retornar sem usar a <em>keyword</em> return

    ```js

    const sum = (number1,number2) => number1 + number2;

    console.log(sum(10, 2)) // OUTPUT: 12

    ```

* sem par√¢metros

    ```js

    const myName = () => 'Gabriela';

    console.log(myName()); // OUTPUT: Gabriela

    ```

* s√≥ um par√¢metro
    * Quando voc√™ tem 1 √∫nico par√¢metro os <strong>par√™nteses se tornam opcionais</strong>

    ```js 
        //com par√™nteses

        const double = (number) => number * 2;
        console.log(double(20)) // OUTPUT: 40

        //sem par√™nteses
        const double = number => number * 2;
        console.log(double(20)) // OUTPUT: 40

    ```
